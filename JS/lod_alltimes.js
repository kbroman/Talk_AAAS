// Generated by CoffeeScript 1.7.1
var draw_lod_alltimes;

draw_lod_alltimes = function(data) {
  var a1, a2, altpink, boundaries, chr, chrEnd, chrEndPixel, chrStart, chrStartPixel, colorScales, curPixel, darkBlue, darkGray, darkRed, e, eff, effCurve, effPlot, effXscale, effYscale, effh, effw, h, hPix, i, imgXscale, imgYscale, imgZscale, imgh, imgw, j, labelcolor, left, lightGray, lodCurve, lodList, lodPlot, lodXscale, lodYscale, lodh, maincolor, maxEff, maxLod, maxPhe, maxVal, minEff, minLod, minLodShown, minPhe, mult, nPix, nodig, onedig, p, pad, panelnames, panels, pheCurve, phePlot, pheYscale, pind, pink, pixelPer, pmarChr, pos, purple, scale, scaleVals, se, seArea, sePlot, svg, ticks, titlecolor, top, totalh, totalpmar, totalw, twodig, w, wScale, ytitle, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _o, _p, _q, _r, _ref, _ref1, _ref2, _ref3, _ref4, _results, _s, _t, _u, _v, _w;
  d3.select("p#loading").remove();
  pixelPer = 1.5;
  darkBlue = "darkslateblue";
  lightGray = d3.rgb(230, 230, 230);
  darkGray = d3.rgb(200, 200, 200);
  pink = "hotpink";
  altpink = "#E9CFEC";
  purple = "#8C4374";
  darkRed = "crimson";
  labelcolor = "white";
  titlecolor = "Wheat";
  maincolor = "Wheat";
  nodig = d3.format(".0f");
  onedig = d3.format(".1f");
  twodig = d3.format(".2f");
  eff = [];
  for (i in data.ave1) {
    eff[i] = [];
    for (j in data.ave1[i]) {
      eff[i][j] = data.ave2[i][j] - data.ave1[i][j];
    }
  }
  pmarChr = {};
  _ref = data.chr;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    chr = _ref[_i];
    for (p in data.map[chr]) {
      pmarChr[p] = chr;
    }
  }
  minLodShown = 1;
  chrStart = {};
  chrEnd = {};
  chrStartPixel = {};
  chrEndPixel = {};
  _ref1 = data.chr;
  for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
    chr = _ref1[_j];
    chrStart[chr] = 999;
    chrEnd[chr] = -999;
  }
  lodList = [];
  _ref2 = data.evenpmar;
  for (pind = _k = 0, _len2 = _ref2.length; _k < _len2; pind = ++_k) {
    p = _ref2[pind];
    i = data.pmarindex[p];
    for (j in data.times) {
      chr = pmarChr[p];
      pos = data.map[chr][p];
      if (chrStart[chr] > pos) {
        chrStart[chr] = pos;
      }
      if (chrEnd[chr] < pos) {
        chrEnd[chr] = pos;
      }
      if (data.lod[i][j] > minLodShown) {
        lodList.push({
          pmar: p,
          row: j * 1,
          effindex: pind,
          chr: pmarChr[p],
          xpos: pos,
          value: data.lod[i][j]
        });
      }
    }
  }
  curPixel = 0;
  imgXscale = {};
  lodXscale = {};
  _ref3 = data.chr;
  for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
    chr = _ref3[_l];
    chrStartPixel[chr] = curPixel;
    chrEndPixel[chr] = curPixel + (chrEnd[chr] - chrStart[chr]) * pixelPer;
    curPixel = chrEndPixel[chr] + pixelPer * 2;
    imgXscale[chr] = d3.scale.linear().domain([chrStart[chr], chrEnd[chr]]).range([chrStartPixel[chr], chrEndPixel[chr]]);
    lodXscale[chr] = d3.scale.linear().domain([chrStart[chr], chrEnd[chr]]).range([chrStartPixel[chr] + pixelPer / 2, chrEndPixel[chr] + pixelPer / 2]);
  }
  totalpmar = data.evenpmar.length;
  pad = {
    left: 50,
    top: 20,
    right: 10,
    bottom: 30,
    inner: 2
  };
  imgw = pixelPer * (totalpmar + data.chr.length - 1);
  imgh = pixelPer * data.times.length;
  lodh = 225;
  effh = (imgh - pad.top - pad.bottom) / 2;
  effw = 400;
  h = [imgh, lodh, effh, effh];
  w = [imgw, imgw, effw, effw];
  left = [pad.left, pad.left, pad.left * 2 + w[0] + pad.right, pad.left * 2 + w[0] + pad.right];
  top = [pad.top, pad.top * 2 + h[0] + pad.bottom, pad.top, pad.top * 2 + h[2] + pad.bottom];
  totalh = h[0] + h[1] + (pad.top + pad.bottom) * 2;
  totalw = (w[0] + w[2]) + (pad.left + pad.right) * 2;
  svg = d3.select("div#lod_alltimes_fig").append("svg").attr("height", totalh).attr("width", totalw);
  panels = [];
  panelnames = ["imagepanel", "lodpanel", "phepanel", "effpanel"];
  for (i = _m = 0; _m < 4; i = ++_m) {
    panels[i] = svg.append("g").attr("id", panelnames[i]).attr("transform", "translate(" + left[i] + ", " + top[i] + ")");
  }
  for (i = _n = 0; _n <= 3; i = ++_n) {
    panels[i].append("rect").attr("height", h[i]).attr("width", w[i]).attr("fill", "white").attr("stroke", "black").attr("stroke-width", 2);
  }
  minEff = 0;
  maxEff = 0;
  minPhe = data.ave1[0][0];
  maxPhe = data.ave1[0][0];
  for (i in data.ave1) {
    for (j in data.ave1[i]) {
      a1 = data.ave1[i][j];
      a2 = data.ave2[i][j];
      e = eff[i][j];
      se = data.se[i][j];
      if (minPhe > a1) {
        minPhe = a1;
      }
      if (maxPhe < a1) {
        maxPhe = a1;
      }
      if (minPhe > a2) {
        minPhe = a2;
      }
      if (maxPhe < a2) {
        maxPhe = a2;
      }
      if (minEff > e - 2 * se) {
        minEff = e - 2 * se;
      }
      if (maxEff < e + 2 * se) {
        maxEff = e + 2 * se;
      }
    }
  }
  maxLod = -1;
  minLod = 50;
  for (i in data.lod) {
    for (j in data.lod[i]) {
      if (maxLod < data.lod[i][j]) {
        maxLod = data.lod[i][j];
      }
      if (minLod > data.lod[i][j]) {
        minLod = data.lod[i][j];
      }
    }
  }
  if (-minEff > maxEff) {
    maxEff = -minEff;
  }
  if (-maxEff < minEff) {
    minEff = -maxEff;
  }
  effYscale = d3.scale.linear().domain([minEff, maxEff]).range([effh - pad.inner, pad.inner]);
  pheYscale = d3.scale.linear().domain([minPhe, maxPhe]).range([effh - pad.inner, pad.inner]);
  lodYscale = d3.scale.linear().domain([0, maxLod]).range([lodh - pad.inner, pad.inner]);
  imgYscale = d3.scale.ordinal().domain(d3.range(data.times.length)).rangePoints([imgh - pixelPer, 0], 0);
  imgZscale = d3.scale.linear().domain([0, maxLod]).range([0, 1]).clamp(true);
  effXscale = d3.scale.linear().domain([d3.min(data.times), d3.max(data.times)]).range([pad.inner, w[2] - pad.inner]);
  boundaries = [];
  _ref4 = data.chr.slice(1);
  for (_o = 0, _len4 = _ref4.length; _o < _len4; _o++) {
    chr = _ref4[_o];
    boundaries.push(chrStartPixel[chr]);
  }
  for (i = _p = 0; _p <= 1; i = ++_p) {
    panels[i].append("g").attr("id", "chrBoundaryLines").selectAll("empty").data(boundaries).enter().append("line").attr("y1", 0).attr("y2", h[i]).attr("x1", function(d) {
      return d - pixelPer * 0.5;
    }).attr("x2", function(d) {
      return d - pixelPer * 0.5;
    }).attr("fill", "none").attr("stroke", "darkGray").attr("stroke-width", 1);
  }
  for (i = _q = 2; _q <= 3; i = ++_q) {
    panels[i].selectAll("empty").data([0, 1, 2, 3, 4, 5, 6, 7, 8]).enter().append("line").attr("y1", 0).attr("y2", h[i]).attr("x1", function(d) {
      return effXscale(d * 60);
    }).attr("x2", function(d) {
      return effXscale(d * 60);
    }).attr("fill", "none").attr("stroke", "darkGray").attr("stroke-width", 1);
    panels[i].selectAll("empty").data([0, 1, 2, 3, 4, 5, 6, 7, 8]).enter().append("text").text(function(d) {
      return d;
    }).attr("y", h[i] + pad.bottom * 0.5).attr("x", function(d) {
      return effXscale(d * 60);
    }).attr("fill", labelcolor).attr("text-anchor", "middle");
  }
  panels[3].append("text").text("Time (hours)").attr("x", w[3] / 2).attr("y", h[3] + pad.bottom).attr("fill", titlecolor).attr("text-anchor", "middle");
  for (i = _r = 0; _r <= 1; i = ++_r) {
    panels[i].append("g").attr("id", "chrLabels").selectAll("empty").data(data.chr).enter().append("text").attr("y", h[i] + pad.bottom * 0.42).attr("x", function(d) {
      return (chrStartPixel[d] + chrEndPixel[d]) / 2;
    }).text(function(d) {
      return d;
    }).attr("fill", labelcolor).attr("text-anchor", "middle");
  }
  panels[1].append("text").text("Chromosome").attr("fill", titlecolor).attr("text-anchor", "middle").attr("x", w[1] / 2).attr("y", h[1] + pad.bottom * 0.9);
  panels[0].append("g").attr("id", "imgYaxisLabels").selectAll("empty").data([0, 1, 2, 3, 4, 5, 6, 7, 8]).enter().append("text").text(function(d) {
    return d;
  }).attr("x", -pad.left * 0.1).attr("y", function(d) {
    return imgYscale(d * 30);
  }).attr("fill", labelcolor).attr("text-anchor", "end").attr("dominant-baseline", "middle");
  panels[0].append("g").attr("id", "imgYaxisGridlines").selectAll("empty").data([1, 2, 3, 4, 5, 6, 7]).enter().append("line").attr("y1", function(d) {
    return imgYscale(d * 30);
  }).attr("y2", function(d) {
    return imgYscale(d * 30);
  }).attr("x1", 0).attr("x2", w[0]).attr("fill", "none").attr("stroke", "lightGray").attr("stroke-width", 1);
  panels[0].append("text").text("Time (hours)").attr("x", -pad.left * 0.6).attr("y", h[0] / 2).attr("text-anchor", "middle").attr("dominant-baseline", "middle").attr("transform", "rotate(270, " + (-pad.left * 0.6) + ", " + (h[0] / 2) + ")").attr("fill", titlecolor);
  ticks = [null, lodYscale.ticks(5), pheYscale.ticks(6), effYscale.ticks(6)];
  scale = [null, lodYscale, pheYscale, effYscale];
  ytitle = [null, "LOD score", "Ave phenotype", "QTL effect (BB - AA)"];
  mult = [null, 0.6, 0.8, 0.7];
  for (i = _s = 1; _s <= 3; i = ++_s) {
    panels[i].selectAll("empty").data(ticks[i]).enter().append("text").text(function(d) {
      return nodig(d);
    }).attr("x", -pad.left * 0.1).attr("y", function(d) {
      return scale[i](d);
    }).attr("fill", function(d) {
      if (d === 0 && i === 3) {
        return pink;
      }
      return labelcolor;
    }).attr("text-anchor", "end").attr("dominant-baseline", "middle");
    panels[i].selectAll("empty").data(ticks[i]).enter().append("line").attr("y1", function(d) {
      return scale[i](d);
    }).attr("y2", function(d) {
      return scale[i](d);
    }).attr("x1", 0).attr("x2", w[i]).attr("fill", "none").attr("stroke", function(d) {
      if (d === 0 && i === 3) {
        return pink;
      }
      return "lightGray";
    }).attr("stroke-width", 1);
    panels[i].append("text").text(ytitle[i]).attr("x", -pad.left * mult[i]).attr("y", h[i] / 2).attr("text-anchor", "middle").attr("dominant-baseline", "middle").attr("transform", "rotate(270, " + (-pad.left * mult[i]) + ", " + (h[i] / 2) + ")").attr("fill", titlecolor);
  }
  panels[2].selectAll("empty").data(["AA", "BB"]).enter().append("text").text(function(d) {
    return d;
  }).attr("x", function(d, i) {
    return effXscale((6.5 + i) * 60);
  }).attr("y", pheYscale(-20) / 2).attr("fill", function(d, g) {
    if (g === 0) {
      return darkBlue;
    }
    return darkRed;
  }).attr("text-anchor", "middle").attr("dominant-baseline", "middle");
  pheCurve = function(pmari, g) {
    return d3.svg.line().x(function(t) {
      return effXscale(t);
    }).y(function(t, i) {
      if (g === 1) {
        return pheYscale(data.ave1[pmari][i]);
      } else {
        return pheYscale(data.ave2[pmari][i]);
      }
    });
  };
  phePlot = function(pmari) {
    var g, pmar, _t;
    for (g = _t = 1; _t <= 2; g = ++_t) {
      panels[2].append("path").attr("id", "pheCurve" + g).datum(data.times).attr("d", pheCurve(pmari, g)).attr("stroke", function() {
        if (g === 1) {
          return darkBlue;
        }
        return darkRed;
      }).attr("fill", "none").attr("stroke-width", "2");
    }
    pmar = data.evenpmar[pmari];
    chr = pmarChr[pmar];
    pos = data.map[chr][pmar];
    return panels[2].append("text").attr("id", "pheTitle").text("Chr " + chr + " @ " + (nodig(pos)) + " cM").attr("x", w[2] / 2).attr("y", -pad.top * 0.6).attr("text-anchor", "middle").attr("dominant-baseline", "middle").attr("fill", maincolor);
  };
  effCurve = function(pmari) {
    return d3.svg.line().x(function(t) {
      return effXscale(t);
    }).y(function(t, i) {
      return effYscale(eff[pmari][i]);
    });
  };
  seArea = function(pmari) {
    return d3.svg.area().x(function(t) {
      return effXscale(t);
    }).y0(function(t, i) {
      return effYscale(eff[pmari][i] - 2 * data.se[pmari][i]);
    }).y1(function(t, i) {
      return effYscale(eff[pmari][i] + 2 * data.se[pmari][i]);
    });
  };
  effPlot = function(pmari) {
    return panels[3].append("path").attr("id", "effCurve").datum(data.times).attr("d", effCurve(pmari)).attr("stroke", darkBlue).attr("fill", "none").attr("stroke-width", "2");
  };
  sePlot = function(pmari) {
    return panels[3].append("path").attr("id", "seArea").datum(data.times).attr("d", seArea(pmari)).attr("stroke", "none").attr("fill", "lightblue").attr("opacity", 0.3);
  };
  lodCurve = function(time, chr) {
    return d3.svg.line().x(function(pmar) {
      return lodXscale[chr](data.map[chr][pmar]);
    }).y(function(pmar) {
      return lodYscale(data.lod[data.pmarindex[pmar]][time]);
    });
  };
  lodPlot = function(time) {
    var retime, _len5, _ref5, _results, _t;
    retime = Math.floor(time * 2 / 60) + Math.round(time * 2 % 60) / 100;
    retime = twodig(retime);
    retime = retime.replace(/\./, ":");
    panels[1].append("text").attr("id", "lodTitle").text("time = " + retime).attr("x", w[1] / 2).attr("y", -pad.top * 0.6).attr("fill", maincolor).attr("text-anchor", "middle").attr("dominant-baseline", "middle");
    _ref5 = data.chr;
    _results = [];
    for (_t = 0, _len5 = _ref5.length; _t < _len5; _t++) {
      chr = _ref5[_t];
      _results.push(panels[1].append("path").attr("id", "lodCurve" + chr).datum(data.allpmar[chr]).attr("d", lodCurve(time, chr)).attr("stroke", darkBlue).attr("fill", "none").attr("stroke-width", "2"));
    }
    return _results;
  };
  panels[0].append("g").attr("id", "imagerect").selectAll("empty").data(lodList).enter().append("rect").attr("x", function(d) {
    return imgXscale[d.chr](d.xpos);
  }).attr("width", pixelPer).attr("y", function(d) {
    return imgYscale(d.row);
  }).attr("height", pixelPer).attr("fill", function(d) {
    if (eff[d.effindex][d.row] < 0) {
      return darkBlue;
    }
    return darkRed;
  }).attr("stroke", function(d) {
    if (eff[d.effindex][d.row] < 0) {
      return darkBlue;
    }
    return darkRed;
  }).attr("stroke-width", 0).attr("opacity", function(d) {
    return imgZscale(d.value);
  }).on("mouseover", function(d) {
    effPlot(d.effindex);
    phePlot(d.effindex);
    return lodPlot(d.row);
  }).on("click", function(d) {
    panels[3].select("path#seArea").remove();
    return sePlot(d.effindex);
  }).on("mouseout", function() {
    var g, _len5, _ref5, _t, _u;
    panels[3].select("path#effCurve").remove();
    panels[3].select("path#seArea").remove();
    for (g = _t = 1; _t <= 2; g = ++_t) {
      panels[2].select("path#pheCurve" + g).remove();
    }
    panels[2].select("text#pheTitle").remove();
    _ref5 = data.chr;
    for (_u = 0, _len5 = _ref5.length; _u < _len5; _u++) {
      chr = _ref5[_u];
      panels[1].select("path#lodCurve" + chr).remove();
    }
    return panels[1].select("text#lodTitle").remove();
  });
  wScale = 25;
  colorScales = [];
  colorScales[0] = panels[1].append("g").attr("id", "blueColorScale").attr("transform", "translate(" + (w[1] + pad.right) + ", 0)");
  colorScales[1] = panels[1].append("g").attr("id", "redColorScale").attr("transform", "translate(" + (w[1] + pad.right * 2 + wScale) + ", 0)");
  for (i = _t = 0; _t <= 1; i = ++_t) {
    colorScales[i].append("rect").attr("x", 0).attr("y", 0).attr("width", wScale).attr("height", h[1]).attr("fill", "white").attr("stroke", "black").attr("stroke-width", 2);
  }
  colorScales[0].append("text").text("Color scales").attr("x", wScale + pad.right / 2).attr("y", -pad.top * 0.5).attr("fill", titlecolor).attr("text-anchor", "middle").attr("dominant-baseline", "middle");
  colorScales[1].selectAll("empty").data(ticks[1]).enter().append("text").text(function(d) {
    return nodig(d);
  }).attr("x", wScale + pad.left * 0.1).attr("y", function(d) {
    return scale[1](d);
  }).attr("fill", labelcolor).attr("text-anchor", "start").attr("dominant-baseline", "middle");
  for (i = _u = 0; _u <= 1; i = ++_u) {
    colorScales[i].selectAll("empty").data(ticks[1]).enter().append("line").attr("y1", function(d) {
      return scale[1](d);
    }).attr("y2", function(d) {
      return scale[1](d);
    }).attr("x1", 0).attr("x2", wScale).attr("fill", "none").attr("stroke", lightGray).attr("stroke-width", 1);
  }
  colorScales[0].selectAll("empty").data(ticks[1]).enter().append("line").attr("y1", function(d) {
    return scale[1](d);
  }).attr("y2", function(d) {
    return scale[1](d);
  }).attr("x1", wScale).attr("x2", wScale + pad.right).attr("fill", "none").attr("stroke", "white").attr("stroke-width", 1);
  scaleVals = [];
  nPix = 128;
  hPix = h[1] / nPix;
  maxVal = maxLod / (h[1] - pad.inner * 2) * h[1];
  for (i = _v = 0; 0 <= nPix ? _v < nPix : _v > nPix; i = 0 <= nPix ? ++_v : --_v) {
    scaleVals.push(i * hPix / h[1] * maxVal);
  }
  _results = [];
  for (i = _w = 0; _w <= 1; i = ++_w) {
    _results.push(colorScales[i].append("g").attr("id", "blueScaleRect").selectAll("empty").data(scaleVals).enter().append("rect").attr("x", 0).attr("width", wScale).attr("y", function(d) {
      return lodYscale(d);
    }).attr("height", hPix).attr("fill", function(d) {
      if (i === 0) {
        return darkBlue;
      }
      return darkRed;
    }).attr("stroke", "none").attr("stroke-width", 0).attr("opacity", function(d) {
      if (d >= 1) {
        return imgZscale(d);
      }
      if (d >= maxLod) {
        return 1;
      }
      return 0;
    }));
  }
  return _results;
};

d3.json("Data/all_lod.json", draw_lod_alltimes);
